<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | Java直达Offer</title><meta name="author" content="Luffy"><meta name="copyright" content="Luffy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面试指导我们是做就业服务的工作室，没有任何培训机构性质！！主做Java、python、c++，前端vue，react等，全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，通过正常上班，不拿offer不收费，不要浪费投递简历的机会和面试机会，如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“就业”即可。   或者添加微信咨询: Java面试指导我们是做就业">
<meta property="og:type" content="website">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://javatooffer.uzibird.cn/interview-java/Java%E5%9F%BA%E7%A1%80.html">
<meta property="og:site_name" content="Java直达Offer">
<meta property="og:description" content="Java面试指导我们是做就业服务的工作室，没有任何培训机构性质！！主做Java、python、c++，前端vue，react等，全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，通过正常上班，不拿offer不收费，不要浪费投递简历的机会和面试机会，如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“就业”即可。   或者添加微信咨询: Java面试指导我们是做就业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg">
<meta property="article:published_time" content="2024-11-04T13:08:38.000Z">
<meta property="article:modified_time" content="2024-12-05T00:20:05.949Z">
<meta property="article:author" content="Luffy">
<meta property="article:tag" content="Java面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg"><link rel="shortcut icon" href="/img/WechatIMG19.jpg"><link rel="canonical" href="https://javatooffer.uzibird.cn/interview-java/Java%E5%9F%BA%E7%A1%80.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-12-05 08:20:05',
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/transpancy.css"><meta name="baidu-site-verification" content="codeva-uXoRJ5heZn"><meta name="google-site-verification" content="tCePosOhrelbl19HIoBruBGDrnG9ccrO4IRZnoEgXhc"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/WechatIMG19.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 面试总结</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/interview-java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/interview-c++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/interview-python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/interview-mysql/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/interview-redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/interview-linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/interview-rabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/interview-Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/interview-kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 编程开发</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/C++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/Python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/MySQL/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/Linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/RabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/Kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/WechatIMG19.jpg" alt="Logo"><span class="site-name">Java直达Offer</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 面试总结</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/interview-java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/interview-c++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/interview-python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/interview-mysql/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/interview-redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/interview-linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/interview-rabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/interview-Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/interview-kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 编程开发</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/C++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/Python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/MySQL/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/Linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/RabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/Kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">Java基础</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 id="Java面试指导"><a href="#Java面试指导" class="headerlink" title="Java面试指导"></a>Java面试指导</h1><p>我们是做就业服务的工作室，没有任何培训机构性质！！<br>主做Java、python、c++，前端vue，react等，<br>全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，<br>通过正常上班，不拿offer不收费，<br>不要浪费投递简历的机会和面试机会，<br>如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“<strong>就业</strong>”即可。</p>
<img src="\img\公众号.png" alt="image-20241203185525611" style="zoom:50%;" />

<p>或者添加微信咨询:<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91-20241114203416.CnGGD6"><img src="https://s1.imagehub.cc/images/2024/11/14/8d89a045c06bcd516471d082e65b7557.th.jpg" alt="添加微信"></a></p>
<h1 id="Java面试指导-1"><a href="#Java面试指导-1" class="headerlink" title="Java面试指导"></a>Java面试指导</h1><p>我们是做就业服务的工作室，没有任何培训机构性质！！<br>主做Java、python、c++，前端vue，react等，<br>全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，<br>通过正常上班，不拿offer不收费，<br>不要浪费投递简历的机会和面试机会，<br>如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“<strong>就业</strong>”即可。</p>
<img src="\img\公众号.png" alt="image-20241203185525611" style="zoom:50%;" />

<p>或者添加微信咨询:<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91-20241114203416.CnGGD6"><img src="https://s1.imagehub.cc/images/2024/11/14/8d89a045c06bcd516471d082e65b7557.th.jpg" alt="添加微信"></a></p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>​    什么是⾯向对象？对⽐⾯向过程，是两种不同的处理问题的⻆度，⾯向过程更注重事情的每⼀个步骤及 顺序，⾯向对象更注重事情有哪些参与者（对象）、及各⾃需要什么，⽐如洗⾐机洗⾐服： </p>
<ul>
<li><p>⾯向过程：会将任务拆解成⼀系列的步骤：打开洗⾐机—–&gt;放⾐服—–&gt;放洗⾐粉—–&gt;清 洗—–&gt;烘⼲ </p>
</li>
<li><p>⾯向对象：会拆出⼈和洗⾐机两个对象：</p>
</li>
</ul>
<p>​		a. ⼈：打开洗⾐机  放⾐服   放洗⾐粉 </p>
<p>​		b. 洗⾐机：清洗   烘⼲ </p>
<p>从以上例⼦能看出，⾯向过程⽐较直接⾼效，⽽⾯向对象更易于复⽤、扩展和维护。</p>
<p><strong>封装</strong>：封装的意义，在于明确标识出允许外部使⽤的所有成员函数和数据项，内部细节对外部调⽤透明，外部调⽤⽆需修改或者关⼼内部实现</p>
<p><strong>继承</strong>：继承基类的⽅法，并做出⾃⼰的改变和&#x2F;或扩展，⼦类共性的⽅法或者属性直接使⽤⽗类的，⽽不 需要⾃⼰再定义，只需扩展⾃⼰个性化的 </p>
<p><strong>多态</strong>：基于对象所属类的不同，外部对同⼀个⽅法的调⽤，实际执⾏的逻辑不同</p>
<h2 id="JDK、JRE、JVM之间的区别"><a href="#JDK、JRE、JVM之间的区别" class="headerlink" title="JDK、JRE、JVM之间的区别"></a>JDK、JRE、JVM之间的区别</h2><ul>
<li><p>JDK：Java Develpment Kit java 开发⼯具 </p>
</li>
<li><p>JRE：Java Runtime Environment  java运⾏时环境 </p>
</li>
<li><p>JVM：java Virtual Machine java 虚拟机</p>
</li>
</ul>
<p><img src="/%5Cimg%5Cjava%5Cimage-20241202160452076.png" alt="image-20241202160452076"></p>
<h2 id="和equals⽅法之前的区别"><a href="#和equals⽅法之前的区别" class="headerlink" title="&#x3D;&#x3D;和equals⽅法之前的区别"></a>&#x3D;&#x3D;和equals⽅法之前的区别</h2><ul>
<li><p>&#x3D;&#x3D;：对⽐的是栈中的值，基本数据类型是变量值，引⽤类型是堆中内存对象的地址 </p>
</li>
<li><p>equals：object中默认也是采⽤&#x3D;&#x3D;⽐较，通常会重写</p>
</li>
</ul>
<p>Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可以看出，String类中被复写的equals()⽅法其实是⽐较两个字符串的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">          <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2; <span class="comment">// 引⽤传递          </span></span><br><span class="line">          System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line">          System.out.println(str1 == str3); <span class="comment">// false</span></span><br><span class="line">          System.out.println(str2 == str3); <span class="comment">// true</span></span><br><span class="line">          System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">          System.out.println(str1.equals(str3)); <span class="comment">// true</span></span><br><span class="line">          System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="hashCode-与equals-之间的关系"><a href="#hashCode-与equals-之间的关系" class="headerlink" title="hashCode()与equals()之间的关系"></a>hashCode()与equals()之间的关系</h2><p>HashCode介绍：hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，Java中的任何类都包含有hashCode()函数。</p>
<p>散列表存储的是键值对(key-value),它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p><strong>以“HashSet如何检查重复”为例子来说明为什么要有hashCode</strong><br>对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，看该位置是否有值，如果没有、HashSet会假设对象没有重复出现。但是如果发现有值，这时会调用equals()方法来检查两个对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的nashcode值，它们也不一定是相等的</li>
<li>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode(0的默认行为是对堆上的对象产生独特值。如果没有重写hashCode(),则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
<h2 id="final关键字的作⽤是什么？"><a href="#final关键字的作⽤是什么？" class="headerlink" title="final关键字的作⽤是什么？"></a>final关键字的作⽤是什么？</h2><p>修饰类：表示类不可被继承<br>修饰方法：表示方法不可被子类覆盖，但是可以重载<br>图灵学院周瑜<br>修饰变量：表示变量一旦被赋值就不可以更改它的值。<br>修饰成员变量：</p>
<ul>
<li>如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。</li>
<li>如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。</li>
</ul>
<p>修饰局部变量：<br>系统不会为局部变量进行初始化，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，<br>即可以在定义时指定默认值（后面的代码不能对变量再赋值），也可以不指定默认值，而在后面的代码<br>中对final变量赋初值（仅一次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVar</span> &#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//再声明的时候就需要赋值或者静态代码块赋值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> static&#123;</span></span><br><span class="line"><span class="comment"> a = 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//再声明的时候就需要赋值或者代码块中赋值或者构造器赋值</span></span><br><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment"> b = 0;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">int</span> localA;   <span class="comment">//局部变量只声明没有初始化，不会报错,与final⽆关。</span></span><br><span class="line">     localA = <span class="number">0</span>;<span class="comment">//在使⽤之前⼀定要赋值</span></span><br><span class="line">	<span class="comment">//localA = 1;  但是不允许第⼆次赋值</span></span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>修饰基本类型数据和引用类型数据：</p>
<ul>
<li>如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；</li>
<li>如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。<strong>但是引用的值是可变的</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalReferenceTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span>[] iArr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">		iArr[<span class="number">2</span>]=-<span class="number">3</span>;<span class="comment">//合法</span></span><br><span class="line">		iArr=nulL;<span class="comment">//非法，对iArr不能重新赋值</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">25</span>);</span><br><span class="line">		p.setAge(<span class="number">24</span>);<span class="comment">//合法</span></span><br><span class="line">		p=nuLL;<span class="comment">//非法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p><strong>为什么局部内部类和匿名内部类只能访问局部final变量?</strong></p>
<p>编译之后会⽣成两个class⽂件，Test.class  Test1.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//局部final变量a,b</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span>&#123;<span class="comment">//jdk8在这里做了优化，不用写，语法糖，但实际上也是</span></span><br><span class="line">有的，也不能修改</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> a <span class="number">10</span>;</span><br><span class="line">		<span class="comment">//匿名内部类</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(a)</span><br><span class="line">				System.out.println(b)</span><br><span class="line">			&#125;:</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outclass</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age <span class="number">12</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outPrint</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x)</span>&#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inclass</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">InPrint</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(x);</span><br><span class="line">				System.out.println(age);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">Inclass</span>().InPrint();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要知道的一点是：内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着<br>方法的执行完毕就被销毁。</p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有<br>没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解<br>决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以<br>访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期</p>
<p>将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修<br>改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</p>
<p>就将局部变量设置为final,对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量<br>和方法的局部变量的一致性。这实际上也是一种妥协。使得局部变量与内部类内建立的拷贝保持一致。</p>
<h2 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h2><ol>
<li>String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的</li>
<li>StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下String Builders效率会更高</li>
</ol>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p><strong>重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。<br><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。 </p>
<h2 id="接⼝和抽象类的区别"><a href="#接⼝和抽象类的区别" class="headerlink" title="接⼝和抽象类的区别"></a>接⼝和抽象类的区别</h2><ul>
<li>抽象类可以存在普通成员函数，而接口中只能存在public abstract方法。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。</li>
<li>抽象类只能继承一个，接口可以实现多个。</li>
</ul>
<p>接口的设计目的，是对类的行为进行约束（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为)，也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。</p>
<p>而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为（记为行为集合A),且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生于一个抽象类。在这个抽象类中实现了B,避免让所有的子类来实现B,这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行)。</p>
<p>抽象类是对类本质的抽象，表达的是is a的关系，比如：BMW is a Car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</p>
<p>而接口是对行为的抽象，表达的是like a的关系。比如：Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁、是如何实现的，接口并不关心。</p>
<p>使用场景：当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也<br>是)每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功<br>能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计<br>阶段会降低难度</p>
<h2 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h2><ul>
<li>List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素</li>
<li>Set:无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素</li>
</ul>
<h2 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h2><ol>
<li>首先，他们的底层数据结构不同，ArrayList)底层是基于数组实现的，LinkedList底层是基于链表实现的</li>
<li>由于底层数据结构不同，他们所适用的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，查询、添加、删除的时间复杂度不同</li>
<li>另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，所以LinkedList还可以当做队列来使⽤</li>
</ol>
<h2 id="HashMap和HashTable有什么区别？其底层实现是什么？"><a href="#HashMap和HashTable有什么区别？其底层实现是什么？" class="headerlink" title="HashMap和HashTable有什么区别？其底层实现是什么？"></a>HashMap和HashTable有什么区别？其底层实现是什么？</h2><p>区别：</p>
<ol>
<li>HashMap方法没有synchronized修饰，线程非安全，HashTable线程安全；</li>
<li>HashMap允许key和value为null,而HashTable不允许</li>
</ol>
<p>底层实现：数组+链表实现，jdk8开始链表高度到8、数组长度超过64，链表转变为红黑树，元素以内部<br>类Node节点存在</p>
<ol>
<li>计算key的hash值，二次hash然后对数组长度取模，对应到数组下标，</li>
<li>如果没有产生hash冲突（下标位置没有元素），则直接创建Node存入数组，</li>
<li>如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64则转变为红黑树，长度低于6则将红黑树转回链表</li>
<li>key为null,存在下标0的位置</li>
</ol>
<h2 id="谈谈ConcurrentHashMap的扩容机制"><a href="#谈谈ConcurrentHashMap的扩容机制" class="headerlink" title="谈谈ConcurrentHashMap的扩容机制"></a>谈谈ConcurrentHashMap的扩容机制</h2><p><strong>1.7版本</strong></p>
<ol>
<li>1.7版本的ConcurrentHashMap是基于Segment分段实现的</li>
<li>每个Segment相对于一个小型的HashMap</li>
<li>每个Segment内部会进行扩容，和HashMap的扩容逻辑类似</li>
<li>先生成新的数组，然后转移元素到新数组中</li>
<li>扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</li>
</ol>
<p><strong>1.8版本</strong></p>
<ol>
<li><p>1.8版本的ConcurrentHashMap不再基于Segment实现</p>
</li>
<li><p>当某个线程进行put时，如果发现ConcurrentHashMap.正在进行扩容那么该线程一起进行扩容</p>
</li>
<li><p>如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</p>
</li>
<li><p>ConcurrentHashMap是支持多个线程同时扩容的</p>
</li>
<li><p>扩容之前也先生成一个新的数组</p>
</li>
<li><p>在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</p>
</li>
</ol>
<h2 id="Jdk1-7到Jdk1-8-HashMap-发⽣了什么变化-底层"><a href="#Jdk1-7到Jdk1-8-HashMap-发⽣了什么变化-底层" class="headerlink" title="Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?"></a>Jdk1.7到Jdk1.8 HashMap 发⽣了什么变化(底层)?</h2><ol>
<li>1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率</li>
<li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入ky和vaue时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法</li>
<li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源</li>
</ol>
<h2 id="说⼀下HashMap的Put⽅法"><a href="#说⼀下HashMap的Put⽅法" class="headerlink" title="说⼀下HashMap的Put⽅法"></a>说⼀下HashMap的Put⽅法</h2><p>先说HashMap的Put方法的大体流程：</p>
<ol>
<li>根据Ky通过哈希算法与与运算得出数组下标</li>
<li>如果数组下标位置元素为空，则将key和value封装为Entry对象(JDK1.7中是Entry:对象，JDK1.8中是Node对象)并放入该位置</li>
<li>如果数组下标位置元素不为空，则要分情况讨论</li>
</ol>
<p>​		a.如果是JDK1.7,则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法添加到当前位置的链表中<br>​		b.如果是JDK1.8,则会先判断当前位置上的Node的类型，看是红黑树Node,还是链表Node<br>​				i. 如果是红黑树Node,则将key和vaue封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key,如果存在则更新value<br>​			   ii. 如果此位置上的Node对象是链表节点，则将key和value封装为一个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链					表，在遍历链表的过程中会判断是否存在当前key,如果存在则更新value,当遍历完链表后，将新链表Node插入到链表中，插入到链表后，会看当前链表					的节点个数，如果大于等于8，那么则会将该链表转成红黑树<br>​			  iii. 将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束PUT方法</p>
<h2 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="headerlink" title="泛型中extends和super的区别"></a>泛型中extends和super的区别</h2><ol>
<li><? extends T>表示包括T在内的任何T的子类</li>
<li>&lt;？super T&gt;表示包括T在内的任何T的父类</li>
</ol>
<h2 id="深拷⻉和浅拷⻉"><a href="#深拷⻉和浅拷⻉" class="headerlink" title="深拷⻉和浅拷⻉"></a>深拷⻉和浅拷⻉</h2><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实<br>例对象的引用。</p>
<ol>
<li>浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象</li>
<li>深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的属性指向的不是同一个对象</li>
</ol>
<h2 id="HashMap的扩容机制原理"><a href="#HashMap的扩容机制原理" class="headerlink" title="HashMap的扩容机制原理"></a>HashMap的扩容机制原理</h2><p>1.7版本</p>
<ol>
<li>先生成新数组</li>
<li>遍历老数组中的每个位置上的链表上的每个元素</li>
<li>取每个元素的key,并基于新数组长度，计算出每个元素在新数组中的下标</li>
<li>将元素添加到新数组中去</li>
<li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li>
</ol>
<p>1.8版本</p>
<ol>
<li>先生成新数组</li>
<li>遍历老数组中的每个位置上的链表或红黑树</li>
<li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去</li>
<li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置</li>
</ol>
<p>​		a.统计每个下标位置的元素个数<br>​		b.如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置<br>​		c.如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置</p>
<ol start="5">
<li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</li>
</ol>
<h2 id="CopyOnWriteArrayList的底层原理是怎样的"><a href="#CopyOnWriteArrayList的底层原理是怎样的" class="headerlink" title="CopyOnWriteArrayList的底层原理是怎样的"></a>CopyOnWriteArrayList的底层原理是怎样的</h2><ol>
<li>首先CopyOnWriteArrayList内部也是用过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li>
<li>并且，写操作会加锁，防止出现并发写入丢失数据的问题</li>
<li>写操作结束之后会把原数组指向新数组</li>
<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>
</ol>
<h2 id="什么是字节码？采⽤字节码的好处是什么？"><a href="#什么是字节码？采⽤字节码的好处是什么？" class="headerlink" title="什么是字节码？采⽤字节码的好处是什么？"></a>什么是字节码？采⽤字节码的好处是什么？</h2><p><strong>Java中的编译器和解释器：</strong> Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展名为.class的文件），它不面向任何特定的处理器，只面向虚拟机。<br>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释并存的特点。</p>
<p>Java源代码—&gt;编译器—-&gt;jvm可执行的Java字节码（即虚拟指令）—-&gt;jvm—-&gt;jvm中解释器——-&gt;机器可执行的二进制机器码——&gt;程序运行。<br><strong>采用字节码的好处：</strong> Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<h2 id="Java中的异常体系是怎样的"><a href="#Java中的异常体系是怎样的" class="headerlink" title="Java中的异常体系是怎样的"></a>Java中的异常体系是怎样的</h2><ul>
<li>Java中的所有异常都来自顶级父类Throwable。</li>
<li>Throwable下有两个子类Exception和Eror。</li>
<li>Ero是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。</li>
<li>Exception不会导致程序停止，又分为两个部分RunTime Exception:运行时异常和CheckedException检查异常。</li>
<li>RunTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。</li>
</ul>
<h2 id="Java中有哪些类加载器"><a href="#Java中有哪些类加载器" class="headerlink" title="Java中有哪些类加载器"></a>Java中有哪些类加载器</h2><p>JDK⾃带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p>
<ul>
<li>BootStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载%JAVA_HOME%Iib下的jar包和class文件。</li>
<li>ExtClassLoader是AppClassLoaderl的父类加载器，负责加载%JAVA_HOME%&#x2F;Iib&#x2F;ext文件夹下的jar包和class类。</li>
<li>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。</li>
</ul>
<h2 id="说说类加载器双亲委派模型"><a href="#说说类加载器双亲委派模型" class="headerlink" title="说说类加载器双亲委派模型"></a>说说类加载器双亲委派模型</h2><p>JVM中存在三个默认的类加载器：</p>
<ol>
<li>BootstrapClassLoader</li>
<li>ExtClassLoader</li>
<li>AppClassLoader</li>
</ol>
<p>AppClassLoader的⽗加载器是ExtClassLoader，ExtClassLoader的⽗加载器是BootstrapClassLoader</p>
<p>JVM在加载⼀个类时，会调⽤AppClassLoader的loadClass⽅法来加载这个类，不过在这个⽅法中，会 先使⽤ExtClassLoader的loadClass⽅法来加载类，同样ExtClassLoader的loadClass⽅法中会先使⽤ BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功，如果 BootstrapClassLoader没有加载到，那么ExtClassLoader就会⾃⼰尝试加载该类，如果没有加载到， 那么则会由AppClassLoader来加载这个类。</p>
<p>所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进⾏加载，如果没加载到才由⾃⼰ 进⾏加载</p>
<h2 id="GC如何判断对象可以被回收"><a href="#GC如何判断对象可以被回收" class="headerlink" title="GC如何判断对象可以被回收"></a>GC如何判断对象可以被回收</h2><ul>
<li>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收，</li>
<li>可达性分析法：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</li>
</ul>
<p>引⽤计数法，可能会出现A 引⽤了 B，B ⼜引⽤了 A，这时候就算他们都不再使⽤了，但因为相互引 ⽤ 计数器&#x3D;1 永远⽆法被回收。</p>
<p>GC Roots的对象有：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNl(即一般说的Native方法)引用的对象</li>
</ul>
<p>可达性算法中的不可达对象并不是⽴即死亡的，对象拥有⼀次⾃我拯救的机会。对象被系统宣告死亡⾄ 少要经历两次标记过程：第⼀次是经过可达性分析发现没有与GC Roots相连接的引⽤链，第⼆次是在 由虚拟机⾃动建⽴的Finalize()队列中判断是否需要执⾏finalize()⽅法。</p>
<p>当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize⽅法，若未覆盖，则直接将其回 收。否则，若对象未执⾏过finalize⽅法，将其放⼊F-Queue队列，由⼀低优先级线程执⾏该队列中对 象的finalize⽅法。执⾏finalize⽅法完毕后，GC会再次判断该对象是否可达，若不可达，则进⾏回收， 否则，对象“复活”</p>
<p>每个对象只能触发⼀次finalize()⽅法</p>
<p>由于finalize()⽅法运⾏代价⾼昂，不确定性⼤，⽆法保证各个对象的调⽤顺序，不推荐⼤家使⽤，建议 遗忘它。</p>
<h2 id="JVM中哪些是线程共享区"><a href="#JVM中哪些是线程共享区" class="headerlink" title="JVM中哪些是线程共享区"></a>JVM中哪些是线程共享区</h2><p>堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的</p>
<p><img src="/%5Cimg%5Cjava%5Cimage-20241202170438657.png" alt="image-20241202170438657"></p>
<h2 id="你们项⽬如何排查JVM问题"><a href="#你们项⽬如何排查JVM问题" class="headerlink" title="你们项⽬如何排查JVM问题"></a>你们项⽬如何排查JVM问题</h2><p>对于还在正常运⾏的系统：</p>
<ol>
<li>可以使用jmap来查看JVM中各个区域的使用情况</li>
<li>可以通过jstack来查看线程的运行情况，比如哪些线程阻塞、是否出现了死锁</li>
<li>可以通过jstat命令来查看垃圾回收的情况，特别是fullgc,如果发现fullgc比较频繁，那么就得进行调优了</li>
<li>通过各个命令的结果，或者jvisualvm等工具来进行分析</li>
<li>首先，初步猜测频繁发送fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则证明修改有效</li>
<li>同时，还可以找到占用CPU最多的线程，定位到具体的方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存</li>
</ol>
<p>对于已经发⽣了OOM的系统：</p>
<ol>
<li>⼀般⽣产系统中都会设置当系统发⽣了OOM时，⽣成当时的dump⽂件（ XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;usr&#x2F;local&#x2F;base）</li>
<li>我们可以利⽤jsisualvm等⼯具来分析dump⽂件</li>
<li>根据dump⽂件找到异常的实例对象，和异常的线程（占⽤CPU⾼），定位到具体的代码</li>
<li>然后再进⾏详细的分析和调试</li>
</ol>
<p>总之，调优不是⼀蹴⽽就的，需要分析、推理、实践、总结、再分析，最终定位到具体的问题</p>
<h2 id="⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？"><a href="#⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？" class="headerlink" title="⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？"></a>⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？</h2><ol>
<li>用户创建一个对象，JVM首先需要到方法区去找对象的类型信息。然后再创建对象。</li>
<li>JVM要实例化一个对象，首先要在堆当中先创建一个对象。-&gt;半初始化状态</li>
<li>对象首先会分配在堆内存中新生代的Eden。然后经过一次Minor GC,对象如果存活，就会进入S区。在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝，每移动一次，年龄加1。-&gt;多大年龄才会移入老年代？年龄最大15，超过一定年龄后，对象转入老年代。</li>
<li>当方法执行结束后，栈中的指针会先移除掉。</li>
<li>堆中的对象，经过Full GC,就会被标记为垃圾，然后被GC线程清理掉。</li>
</ol>
<h2 id="怎么确定⼀个对象到底是不是垃圾？"><a href="#怎么确定⼀个对象到底是不是垃圾？" class="headerlink" title="怎么确定⼀个对象到底是不是垃圾？"></a>怎么确定⼀个对象到底是不是垃圾？</h2><ol>
<li>引⽤计数： 这种⽅式是给堆内存当中的每个对象记录⼀个引⽤个数。引⽤个数为0的就认为是垃 圾。这是早期JDK中使⽤的⽅式。引⽤计数⽆法解决循环引⽤的问题。</li>
<li>根可达算法： 这种⽅式是在内存中，从引⽤根对象向下⼀直找引⽤，找不到的对象就是垃圾。</li>
</ol>
<h2 id="JVM有哪些垃圾回收算法？"><a href="#JVM有哪些垃圾回收算法？" class="headerlink" title="JVM有哪些垃圾回收算法？"></a>JVM有哪些垃圾回收算法？</h2><ol>
<li>MarkSweep 标记清除算法：这个算法分为两个阶段，标记阶段：把垃圾内存标记出来，清除阶 段：直接将垃圾内存回收。这种算法是⽐较简单的，但是有个很严重的问题，就是会产⽣⼤量的内 存碎⽚。</li>
<li>Copying 拷⻉算法：为了解决标记清除算法的内存碎⽚问题，就产⽣了拷⻉算法。拷⻉算法将内存 分为⼤⼩相等的两半，每次只使⽤其中⼀半。垃圾回收时，将当前这⼀块的存活对象全部拷⻉到另 ⼀半，然后当前这⼀半内存就可以直接清除。这种算法没有内存碎⽚，但是他的问题就在于浪费空 间。⽽且，他的效率跟存货对象的个数有关。</li>
<li>MarkCompack 标记压缩算法：为了解决拷⻉算法的缺陷，就提出了标记压缩算法。这种算法在标 记阶段跟标记清除算法是⼀样的，但是在完成标记之后，不是直接清理垃圾内存，⽽是将存活对象 往⼀端移动，然后将端边界以外的所有内存直接清除。</li>
</ol>
<p>这三种算法各有利弊，各⾃有各⾃的适合场景。</p>
<h2 id="什么是STW？"><a href="#什么是STW？" class="headerlink" title="什么是STW？"></a>什么是STW？</h2><p>STW: Stop-The-World，是在垃圾回收算法执⾏过程当中，需要将JVM内存冻结的⼀种状态。在STW 状态下，JAVA的所有线程都是停⽌执⾏的-GC线程除外，native⽅法可以执⾏，但是，不能与JVM交 互。GC各种算法优化的重点，就是减少STW，同时这也是JVM调优的重点。</p>
<h2 id="JVM有哪些垃圾回收器？"><a href="#JVM有哪些垃圾回收器？" class="headerlink" title="JVM有哪些垃圾回收器？"></a>JVM有哪些垃圾回收器？</h2><ul>
<li>新⽣代收集器：</li>
</ul>
<p>​		Serial</p>
<p>​		ParNew</p>
<p>​		Parallel Scavenge</p>
<ul>
<li>老年代收集器：</li>
</ul>
<p>​		CMS</p>
<p>​		Serial Old</p>
<p>​		Parallel Old</p>
<ul>
<li>整堆收集器：</li>
</ul>
<p>​		G1</p>
<h2 id="垃圾回收分为哪些阶段"><a href="#垃圾回收分为哪些阶段" class="headerlink" title="垃圾回收分为哪些阶段"></a>垃圾回收分为哪些阶段</h2><p> GC分为四个阶段：</p>
<ul>
<li>第一：初始标记标记出GCRoot]直接引用的对象。STW</li>
<li>第二：标记Region,通过RSet标记出上一个阶段标记的Region引用到的Old区Region。</li>
<li>第三：并发标记阶段：跟CMS的步骤是差不多的。只是遍历的范围不再是整个OI区，而只需要遍历第二步标记出来的Region。</li>
<li>第四：重新标记：跟CMS中的重新标记过程是差不多的。</li>
<li>第五：垃圾清理：与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝到另一个Region。而这个阶段，G1只选择垃圾较多的Region来清理，并不是完全清理。</li>
</ul>
<h2 id="什么是三⾊标记？"><a href="#什么是三⾊标记？" class="headerlink" title="什么是三⾊标记？"></a>什么是三⾊标记？</h2><p>三⾊标记：是⼀种逻辑上的抽象。将每个内存对象分成三种颜⾊： </p>
<ol>
<li>⿊⾊：表示⾃⼰和成员变量都已经标记完毕。</li>
<li>灰⾊：⾃⼰标记完了，但是成员变量还没有完全标记完。</li>
<li>⽩⾊：⾃⼰未标记完。</li>
</ol>
<h2 id="JVM参数有哪些？"><a href="#JVM参数有哪些？" class="headerlink" title="JVM参数有哪些？"></a>JVM参数有哪些？</h2><p>JVM参数⼤致可以分为三类：</p>
<ol>
<li>标注指令： -开头，这些是所有的HotSpot都⽀持的参数。可以⽤java -help 打印出来。</li>
<li>⾮标准指令： -X开头，这些指令通常是跟特定的HotSpot版本对应的。可以⽤java -X 打印出来。</li>
<li>不稳定参数： -XX 开头，这⼀类参数是跟特定HotSpot版本对应的，并且变化⾮常⼤。详细的⽂档 资料⾮常少。在JDK1.8版本下，有⼏个常⽤的不稳定指令：</li>
</ol>
<p>​		java -XX:+PrintCommandLineFlags ： 查看当前命令的不稳定指令。</p>
<p>​		java -XX:+PrintFlagsInitial ： 查看所有不稳定指令的默认值。</p>
<p>​		java -XX:+PrintFlagsFinal： 查看所有不稳定指令最终⽣效的实际值。</p>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WechatIMG19.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Luffy</div><div class="author-info-description">100%包拿Offer</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" href="/img/公众号.png"><i class="fab fa-weixin"></i><span>关注公众号</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zlf521000/JavaOfferToYou" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:luffy13453500082@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/WechatIMG35.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #1AAD19;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">面试指导，100%帮您拿Offer，不拿Offer不收费！！！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/06/%E9%9D%A2%E8%AF%95%E9%A2%84%E7%BA%A6/" title="面试预约"><img src="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试预约"/></a><div class="content"><a class="title" href="/2024/12/06/%E9%9D%A2%E8%AF%95%E9%A2%84%E7%BA%A6/" title="面试预约">面试预约</a><time datetime="2024-12-06T10:25:56.000Z" title="发表于 2024-12-06 18:25:56">2024-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/28/Autowird-vs-Resource/" title="Autowird_vs_Resource"><img src="https://s1.imagehub.cc/images/2024/11/28/bab171eb86cb158d84460d755e65e039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Autowird_vs_Resource"/></a><div class="content"><a class="title" href="/2024/11/28/Autowird-vs-Resource/" title="Autowird_vs_Resource">Autowird_vs_Resource</a><time datetime="2024-11-28T11:09:48.000Z" title="发表于 2024-11-28 19:09:48">2024-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89/" title="创建群聊客服聊天系统（4）"><img src="https://s1.imagehub.cc/images/2024/11/21/68f645d9cdba8f558c74809fe995a988.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建群聊客服聊天系统（4）"/></a><div class="content"><a class="title" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89/" title="创建群聊客服聊天系统（4）">创建群聊客服聊天系统（4）</a><time datetime="2024-11-21T11:32:44.000Z" title="发表于 2024-11-21 19:32:44">2024-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89/" title="创建群聊客服聊天系统（3）"><img src="https://s1.imagehub.cc/images/2024/11/21/8ebb58f8f0a0b154cee1325a1f390106.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建群聊客服聊天系统（3）"/></a><div class="content"><a class="title" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89/" title="创建群聊客服聊天系统（3）">创建群聊客服聊天系统（3）</a><time datetime="2024-11-21T11:32:39.000Z" title="发表于 2024-11-21 19:32:39">2024-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/17/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/" title="如何用TelegramBot创建群聊客服聊天系统（2）"><img src="https://s1.imagehub.cc/images/2024/11/17/b77975b53434e94225b9eb404f9ec652.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何用TelegramBot创建群聊客服聊天系统（2）"/></a><div class="content"><a class="title" href="/2024/11/17/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/" title="如何用TelegramBot创建群聊客服聊天系统（2）">如何用TelegramBot创建群聊客服聊天系统（2）</a><time datetime="2024-11-17T14:12:25.000Z" title="发表于 2024-11-17 22:12:25">2024-11-17</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Offer/" style="font-size: 1.23em; color: #999ea6">Offer</a> <a href="/tags/Java/" style="font-size: 1.5em; color: #99a9bf">Java</a> <a href="/tags/VPN/" style="font-size: 1.1em; color: #999">VPN</a> <a href="/tags/Telegram-Bot/" style="font-size: 1.37em; color: #99a4b2">Telegram_Bot</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
    <ul class="card-archive-list">
  
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2024/12/">
          <span class="card-archive-list-date">十二月 2024</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2024/11/">
          <span class="card-archive-list-date">十一月 2024</span>
          <span class="card-archive-list-count">19</span>
        </a>
      </li>
    </ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">20</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-12-06T11:02:06.673Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Luffy</div></div></footer><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>