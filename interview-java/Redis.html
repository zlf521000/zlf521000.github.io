<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | Java直达Offer</title><meta name="author" content="Luffy"><meta name="copyright" content="Luffy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java面试指导我们是做就业服务的工作室，没有任何培训机构性质！！主做Java、python、c++，前端vue，react等，全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，通过正常上班，不拿offer不收费，不要浪费投递简历的机会和面试机会，如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“就业”即可。   或者添加微信咨询: Redis什么是RDB和AO">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://javatooffer.uzibird.cn/interview-java/Redis.html">
<meta property="og:site_name" content="Java直达Offer">
<meta property="og:description" content="Java面试指导我们是做就业服务的工作室，没有任何培训机构性质！！主做Java、python、c++，前端vue，react等，全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，通过正常上班，不拿offer不收费，不要浪费投递简历的机会和面试机会，如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“就业”即可。   或者添加微信咨询: Redis什么是RDB和AO">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg">
<meta property="article:published_time" content="2024-11-04T13:08:38.000Z">
<meta property="article:modified_time" content="2024-12-05T00:20:13.038Z">
<meta property="article:author" content="Luffy">
<meta property="article:tag" content="Java面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg"><link rel="shortcut icon" href="/img/WechatIMG19.jpg"><link rel="canonical" href="https://javatooffer.uzibird.cn/interview-java/Redis.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-12-05 08:20:13',
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/transpancy.css"><meta name="baidu-site-verification" content="codeva-uXoRJ5heZn"><meta name="google-site-verification" content="tCePosOhrelbl19HIoBruBGDrnG9ccrO4IRZnoEgXhc"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/WechatIMG19.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 面试总结</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/interview-java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/interview-c++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/interview-python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/interview-mysql/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/interview-redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/interview-linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/interview-rabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/interview-Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/interview-kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 编程开发</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/C++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/Python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/MySQL/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/Linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/RabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/Kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div></div></div></div><div id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/WechatIMG19.jpg" alt="Logo"><span class="site-name">Java直达Offer</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 面试总结</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/interview-java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/interview-c++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/interview-python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/interview-mysql/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/interview-redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/interview-linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/interview-rabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/interview-Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/interview-kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 编程开发</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/Java/"><i class="fa-fw fab fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/C++/"><i class="fa-fw fas fa-code"></i><span> C++</span></a></li><li><a class="site-page child" href="/Python/"><i class="fa-fw fab fa-python"></i><span> Python</span></a></li><li><a class="site-page child" href="/MySQL/"><i class="fa-fw fas fa-database"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Redis/"><i class="fa-fw fas fa-memory"></i><span> Redis</span></a></li><li><a class="site-page child" href="/Linux/"><i class="fa-fw fab fa-linux"></i><span> Linux</span></a></li><li><a class="site-page child" href="/RabbitMQ/"><i class="fa-fw fas fa-server"></i><span> RabbitMQ</span></a></li><li><a class="site-page child" href="/Spring/"><i class="fa-fw fas fa-leaf"></i><span> Spring</span></a></li><li><a class="site-page child" href="/Kafka/"><i class="fa-fw fas fa-stream"></i><span> Kafka</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title">Redis</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><h1 id="Java面试指导"><a href="#Java面试指导" class="headerlink" title="Java面试指导"></a>Java面试指导</h1><p>我们是做就业服务的工作室，没有任何培训机构性质！！<br>主做Java、python、c++，前端vue，react等，<br>全国各地，简历包装，投递邀约，视频面试，技术面试包通过，离职背调等，<br>通过正常上班，不拿offer不收费，<br>不要浪费投递简历的机会和面试机会，<br>如果已经在职的话，并且不满意目前薪资也可以联系我们。关注公众号回复“<strong>就业</strong>”即可。</p>
<img src="\img\公众号.png" alt="image-20241203185525611" style="zoom:50%;" />

<p>或者添加微信咨询:<br><a target="_blank" rel="noopener" href="https://www.imagehub.cc/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91-20241114203416.CnGGD6"><img src="https://s1.imagehub.cc/images/2024/11/14/8d89a045c06bcd516471d082e65b7557.th.jpg" alt="添加微信"></a></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="什么是RDB和AOF"><a href="#什么是RDB和AOF" class="headerlink" title="什么是RDB和AOF"></a>什么是RDB和AOF</h2><p>RDB：Redis DataBase，在指定的时间间隔内将内存中的数据集快照写⼊磁盘，实际操作过程是fork⼀ 个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。</p>
<p><strong>优点：</strong></p>
<ol>
<li>整个Redis数据库将只包含一个文件dump.rdb,方便持久化。</li>
<li>容灾性好，方便备份。</li>
<li>性能最大化，f和k子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了r©dis的高性能</li>
<li>相对于数据集大时，比AOF的启动效率更高。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间dis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
<p>AOF：Append Only File，以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记 录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录</p>
<p><strong>优点：</strong></p>
<ol>
<li>数据安全，Rds中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。。</li>
<li>通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis.check-aof工具解决数据一致性问题。</li>
<li>AOF机制的rewrite模式。定期对AOF文件进行重写，以达到压缩的目的</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>AOF文件比RDB文件大，且恢复速度慢。</li>
<li>数据集大的时候，比rdb启动效率低。</li>
<li>运行效率没有RDB高</li>
</ol>
<p>AOF⽂件⽐RDB更新频率⾼，优先使⽤AOF还原数据，AOF⽐RDB更安全也更⼤，RDB性能⽐AOF好， 如果两个都配了优先加载AOF。</p>
<h2 id="Redis的过期键的删除策略"><a href="#Redis的过期键的删除策略" class="headerlink" title="Redis的过期键的删除策略"></a>Redis的过期键的删除策略</h2><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当 Redis中缓存的key过期了，Redis如何处理。</p>
<ul>
<li><strong>惰性过期：</strong>只有当访问⼀个key时，才会判断该key是否已过期，过期则清除。该策略可以最⼤化地 节省CPU资源，却对内存⾮常不友好。极端情况可能出现⼤量的过期key没有再次被访问，从⽽不 会被清除，占⽤⼤量内存。</li>
<li><strong>定期过期：</strong>每隔⼀定的时间，会扫描⼀定数量的数据库的expires字典中⼀定数量的key，并清除其 中已过期的key。该策略是⼀个折中⽅案。通过调整定时扫描的时间间隔和每次扫描的限定耗时， 可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的 指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。）</p>
<p> Redis中同时使⽤了惰性过期和定期过期两种过期策略。</p>
<h2 id="Redis线程模型、单线程快的原因"><a href="#Redis线程模型、单线程快的原因" class="headerlink" title="Redis线程模型、单线程快的原因"></a>Redis线程模型、单线程快的原因</h2><p>Redis基于Reactor模式开发了⽹络事件处理器，这个处理器叫做⽂件事件处理器 file event handler。 这个⽂件事件处理器，它是单线程的，所以 Redis 才叫做单线程的模型，它采⽤IO多路复⽤机制来同时 监听多个Socket，根据Socket上的事件类型来选择对应的事件处理器来处理这个事件。可以实现⾼性能 的⽹络通信模型，⼜可以跟内部其他单线程的模块进⾏对接，保证了 Redis 内部的线程模型的简单性。</p>
<p>⽂件事件处理器的结构包含4个部分：多个Socket、IO多路复⽤程序、⽂件事件分派器以及事件处理器 （命令请求处理器、命令回复处理器、连接应答处理器等）。</p>
<p>多个 Socket 可能并发的产⽣不同的操作，每个操作对应不同的⽂件事件，但是IO多路复⽤程序会监听 多个 Socket，会将 Socket 放⼊⼀个队列中排队，每次从队列中取出⼀个 Socket 给事件分派器，事件 分派器把 Socket 给对应的事件处理器。</p>
<p>然后⼀个 Socket 的事件处理完之后，IO多路复⽤程序才会将队列中的下⼀个 Socket 给事件分派器。 ⽂件事件分派器会根据每个 Socket 当前产⽣的事件，来选择对应的事件处理器来处理。</p>
<p>单线程快的原因：</p>
<ol>
<li>纯内存操作</li>
<li>核⼼是基于⾮阻塞的IO多路复⽤机制</li>
<li>单线程反⽽避免了多线程的频繁上下⽂切换带来的性能问题</li>
</ol>
<h2 id="简述Redis事务实现"><a href="#简述Redis事务实现" class="headerlink" title="简述Redis事务实现"></a>简述Redis事务实现</h2><ol>
<li><p><strong>事务开始</strong></p>
<p>MULTI命令的执⾏，标识着⼀个事务的开始。MULTI命令会将客户端状态的 flags  属性中打开REDIS_MULTI  标识来完成的。</p>
</li>
<li><p><strong>命令⼊队</strong></p>
<p>当⼀个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执⾏不同的操作。如果客 户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的⼀个，⽴即执⾏这个命令，否则将命令放 ⼊⼀个事务队列⾥⾯，然后向客户端返回 QUEUED  回复</p>
<ul>
<li>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中⼀个，那么服务 器⽴即执⾏这个命令。</li>
<li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不⽴即执⾏这个命令。 ⾸先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属 性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。 如果正确，将这个命令放⼊⼀个事务队列⾥⾯，然后向客户端返回 QUEUED 回复</li>
</ul>
<p>事务队列是按照FIFO的⽅式保存⼊队的命令</p>
</li>
<li><p><strong>事务执⾏</strong></p>
</li>
</ol>
<p>客户端发送 EXEC 命令，服务器执⾏ EXEC 命令逻辑。</p>
<ul>
<li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者  REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执⾏。</li>
<li>否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然 后执⾏事务队列中的所有命令，最后将返回结果全部返回给客户端；</li>
</ul>
<p>redis 不⽀持事务回滚机制，但是它会检查每⼀个事务中的命令是否错误。</p>
<p>Redis 事务不⽀持检查那些程序员⾃⼰逻辑错误。例如对 String 类型的数据库键执⾏对 HashMap 类型 的操作！</p>
<ul>
<li>WATCH 命令是⼀个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）⾏为。可以监控⼀ 个或多个键，⼀旦其中有⼀个键被修改（或删除），之后的事务就不会执⾏，监控⼀直持续到 EXEC命令。</li>
<li>MULTI命令⽤于开启⼀个事务，它总是返回OK。MULTI执⾏之后，客户端可以继续向服务器发送 任意多条命令，这些命令不会⽴即被执⾏，⽽是被放到⼀个队列中，当EXEC命令被调⽤时，所有 队列中的命令才会被执⾏。</li>
<li>EXEC：执⾏所有事务块内的命令。返回事务块内所有命令的返回值，按命令执⾏的先后顺序排 列。当操作被打断时，返回空值 nil 。</li>
<li>通过调⽤DISCARD，客户端可以清空事务队列，并放弃执⾏事务， 并且客户端会从事务状态中退 出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h2 id="Redis-主从复制的核⼼原理"><a href="#Redis-主从复制的核⼼原理" class="headerlink" title="Redis 主从复制的核⼼原理"></a>Redis 主从复制的核⼼原理</h2><p>通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进 ⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接 受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数据库。</p>
<p>全量复制：</p>
<p>主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬盘IO的</p>
<p>主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗</p>
<p>从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏ bgrewriteaof，也会带来额外的消耗</p>
<p>部分复制：</p>
<ol>
<li><strong>复制偏移量：</strong>执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset</li>
<li><strong>复制积压缓冲区：</strong>主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区， 当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。</li>
<li><strong>服务器运⾏ID(runid)：</strong>每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会 将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时 候，就是根据运⾏ID来判断同步的进度：</li>
</ol>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续 尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不 是当前的主节点，只能进⾏全量复制。</li>
</ul>
<h2 id="Redis有哪些数据结构？分别有哪些典型的应⽤场景？"><a href="#Redis有哪些数据结构？分别有哪些典型的应⽤场景？" class="headerlink" title="Redis有哪些数据结构？分别有哪些典型的应⽤场景？"></a>Redis有哪些数据结构？分别有哪些典型的应⽤场景？</h2><p>Redis的数据结构有：</p>
<ol>
<li>字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符 串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式 ID</li>
<li>哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</li>
<li>列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似 微信公众号、微博等消息流数据</li>
<li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作， 从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</li>
<li>有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</li>
</ol>
<h2 id="Redis分布式锁底层是如何实现的？"><a href="#Redis分布式锁底层是如何实现的？" class="headerlink" title="Redis分布式锁底层是如何实现的？"></a>Redis分布式锁底层是如何实现的？</h2><ol>
<li>⾸先利⽤setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁</li>
<li>然后还要利⽤lua脚本来保证多个redis操作的原⼦性</li>
<li>同时还要考虑到锁过期，所以需要额外的⼀个看⻔狗定时任务来监听锁是否需要续约</li>
<li>同时还要考虑到redis节点挂掉后的情况，所以需要采⽤红锁的⽅式来同时向N&#x2F;2+1个节点申请锁， 都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</li>
</ol>
<h2 id="Redis主从复制的核⼼原理"><a href="#Redis主从复制的核⼼原理" class="headerlink" title="Redis主从复制的核⼼原理"></a>Redis主从复制的核⼼原理</h2><p>Redis的主从复制是提⾼Redis的可靠性的有效措施，主从复制的流程如下：</p>
<ol>
<li>集群启动时，主从库间会先建⽴连接，为全量复制做准备</li>
<li>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照 RDB</li>
<li>在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis的服务就被中断 了。但是，这些请求中的写操作并没有记录到刚刚⽣成的RDB⽂件中。为了保证主从库的数据⼀致性，主 库会在内存中⽤专⻔的replication buffer，记录RDB⽂件⽣成收到的所有写操作。</li>
<li>最后，也就是第三个阶段，主库会把第⼆阶段执⾏过程中新收到的写命令，再发送给从库。具体的操作 是，当主库完成RDB⽂件发送后，就会把此时replocation buffer中修改操作发送给从库，从库再执⾏这些 操作。这样⼀来，主从库就实现同步了</li>
<li>后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操 作发送给从库，实现增量同步</li>
</ol>
<h2 id="Redis集群策略"><a href="#Redis集群策略" class="headerlink" title="Redis集群策略"></a>Redis集群策略</h2><p>Redis提供了三种集群策略：</p>
<ol>
<li>主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端 直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐ 较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</li>
<li>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕 机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵 节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤， 但是仍然不能很好的解决Redis的容量上限问题。</li>
<li>Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的 分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数 据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举 ⼀个新的主节点。</li>
</ol>
<p>对于这三种模式，如果Redis要存的数据量不⼤，可以选择哨兵模式，如果Redis要存的数据量⼤，并且 需要持续的扩容，那么选择Cluster模式。</p>
<h2 id="缓存穿透、缓存击穿、缓存雪崩分别是什么"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么"></a>缓存穿透、缓存击穿、缓存雪崩分别是什么</h2><p>缓存中存放的⼤多都是热点数据，⽬的就是防⽌请求可以直接从缓存中获取到数据，⽽不⽤访问 Mysql。</p>
<ol>
<li>缓存雪崩：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问Mysql 了，解决办法就是在过期时间上增加⼀点随机值，另外如果搭建⼀个⾼可⽤的Redis集群也是防⽌ 缓存雪崩的有效⼿段</li>
<li>缓存击穿：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点key突然 失效，也导致了⼤量请求直接访问Mysql数据库，这就是缓存击穿，解决⽅案就是考虑这个热点key 不设过期时间</li>
<li>缓存穿透：假如某⼀时刻访问redis的⼤量key都在redis中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟 的key），那么也会给数据造成压⼒，这就是缓存穿透，解决⽅案是使⽤布隆过滤器，它的作⽤就 是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器 来拦截不存在的key</li>
</ol>
<h2 id="Redis和Mysql如何保证数据⼀致"><a href="#Redis和Mysql如何保证数据⼀致" class="headerlink" title="Redis和Mysql如何保证数据⼀致"></a>Redis和Mysql如何保证数据⼀致</h2><ol>
<li>先更新Mysql，再更新Redis，如果更新Redis失败，可能仍然不⼀致</li>
<li>先删除Redis缓存数据，再更新Mysql，再次查询的时候在将数据添加到缓存中，这种⽅案能解决1 ⽅案的问题，但是在⾼并发下性能较低，⽽且仍然会出现数据不⼀致的问题，⽐如线程1删除了 Redis缓存数据，正在更新Mysql，此时另外⼀个查询再查询，那么就会把Mysql中⽼数据⼜查到 Redis中</li>
<li>延时双删，步骤是：先删除Redis缓存数据，再更新Mysql，延迟⼏百毫秒再删除Redis缓存数据， 这样就算在更新Mysql时，有其他线程读了Mysql，把⽼数据读到了Redis中，那么也会被删除掉， 从⽽把数据保持⼀致</li>
</ol>
<h2 id="Redis的持久化机制"><a href="#Redis的持久化机制" class="headerlink" title="Redis的持久化机制"></a>Redis的持久化机制</h2><p>RDB：Redis DataBase 将某⼀个时刻的内存快照（Snapshot），以⼆进制的⽅式写⼊磁盘。 </p>
<p>⼿动触发：</p>
<ul>
<li>save命令，使 Redis 处于阻塞状态，直到 RDB 持久化完成，才会响应其他客户端发来的命令，所 以在⽣产环境⼀定要慎⽤</li>
<li>bgsave命令，fork出⼀个⼦进程执⾏持久化，主进程只在fork过程中有短暂的阻塞，⼦进程创建        之后，主进程就可以响应客户端请求了</li>
<li>⾃动触发：</li>
<li>save m n ：在 m 秒内，如果有 n 个键发⽣改变，则⾃动触发持久化，通过bgsave执⾏，如果设 置多个、只要满⾜其⼀就会触发，配置⽂件有默认配置(可以注释掉)</li>
<li>flushall：⽤于清空redis所有的数据库，flushdb清空当前redis所在库数据(默认是0号数据库)，会   清空RDB⽂件，同时也会⽣成dump.rdb、内容为空</li>
<li>主从同步：全量同步时会⾃动触发bgsave命令，⽣成rdb发送给从节点</li>
</ul>
<p>优点：</p>
<ol>
<li>整个Redis数据库将只包含⼀个⽂件   dump.rdb，⽅便持久化。</li>
<li>容灾性好，⽅便备份。</li>
<li>性能最⼤化，fork ⼦进程来完成写操作，让主进程继续处理命令，所以是 IO 最⼤化。使⽤单独⼦ 进程来进⾏持久化，主进程不会进⾏任何 IO 操作，保证了 redis 的⾼性能</li>
<li>相对于数据集⼤时，⽐ AOF的启动效率更⾼。</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据安全性低。RDB 是间隔⼀段时间进⾏持久化，如果持久化之间 redis 发⽣故障，会发⽣数据丢 失。所以这种⽅式更适合数据要求不严谨的时候)</li>
<li>由于RDB是通过fork⼦进程来协助完成数据持久化⼯作的，因此，如果当数据集较⼤时，可能会导 致整个服务器停⽌服务⼏百毫秒，甚⾄是1秒钟。会占⽤cpu</li>
</ol>
<p>AOF：Append Only File 以⽇志的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录， 以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录，调操作系统命令进程刷盘</p>
<ol>
<li>所有的写命令会追加到 AOF 缓冲中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘进⾏同步操作。</li>
<li>随着 AOF ⽂件越来越⼤，需要定期对 AOF ⽂件进⾏重写，达到压缩的⽬的。</li>
<li>当 Redis 重启时，可以加载 AOF ⽂件进⾏数据恢复。同步策略：</li>
<li>每秒同步：异步完成，效率⾮常⾼，⼀旦系统出现宕机现象，那么这⼀秒钟之内修改的数据将会丢  失 每修改同步：同步持久化，每次发⽣的数据变化都会被⽴即记录到磁盘中，最多丢⼀条 不同步：由操作 系统控制，可能丢失较多数据</li>
</ol>
<p>优点：</p>
<ol>
<li>数据安全</li>
<li>通过 append 模式写⽂件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-  check-aof ⼯具解决数据⼀致性问题。</li>
<li>AOF 机制的 rewrite 模式。定期对AOF⽂件进⾏重写，以达到压缩的⽬的</li>
</ol>
<p>缺点：</p>
<ol>
<li>AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。</li>
<li>数据集⼤的时候，⽐ rdb 启动效率低。</li>
<li>运⾏效率没有RDB⾼</li>
</ol>
<p>对⽐：</p>
<ul>
<li>AOF⽂件⽐RDB更新频率⾼，优先使⽤AOF还原数据。AOF⽐RDB更安全也更⼤</li>
<li>RDB性能⽐AOF好</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<h2 id="Redis单线程为什么这么快"><a href="#Redis单线程为什么这么快" class="headerlink" title="Redis单线程为什么这么快"></a>Redis单线程为什么这么快</h2><p>Redis基于Reactor模式开发了⽹络事件处理器、⽂件事件处理器 fileeventhandler。它是单线程的， 所 以 Redis才叫做单线程的模型，它采⽤IO多路复⽤机制来同时监听多个Socket，根据Socket上的事件类 型来选择对应的事件处理器来处理这个事件。可以实现⾼性能的⽹络通信模型，⼜可以跟内部其他单   线程的模块进⾏对接，保证了 Redis内部的线程模型的简单性。</p>
<p>⽂件事件处理器的结构包含4个部分：多个Socket、IO多路复⽤程序、⽂件事件分派器以及事件处理器 （命令请求处理器、命令回复处理器、连接应答处理器等）。</p>
<p>多个 Socket 可能并发的产⽣不同的事件，IO多路复⽤程序会监听多个 Socket，会将 Socket 放⼊⼀个 队列中排队，每次从队列中有序、同步取出⼀个 Socket 给事件分派器，事件分派器把 Socket 给对应 的事件处理器。</p>
<p>然后⼀个 Socket 的事件处理完之后，IO多路复⽤程序才会将队列中的下⼀个 Socket 给事件分派器。 ⽂件事件分派器会根据每个 Socket 当前产⽣的事件，来选择对应的事件处理器来处理。</p>
<ol>
<li>Redis启动初始化时，将连接应答处理器跟AE_READABLE事件关联。</li>
<li>若⼀个客户端发起连接，会产⽣⼀个AE_READABLE事件，然后由连接应答处理器负责和客户端建 ⽴      连接，创建客户端对应的socket，同时将这个socket的AE_READABLE事件和命令请求处理 器关联，使 得客户端可以向主服务器发送命令请求。</li>
<li>当客户端向Redis发请求时（不管读还是写请求），客户端socket都会产⽣⼀个AE_READABLE事 件，触发命令请求处理器。处理器读取客户端的命令内容， 然后传给相关程序执⾏。</li>
<li>当Redis服务器准备好给客户端的响应数据后，会将socket的AE_WRITABLE事件和命令回复处理 器关联，当客户端准备好读取响应数据时，会在socket产⽣⼀个AE_WRITABLE事件，由对应命令 回复处  理器处理，即将准备好的响应数据写⼊socket，供客户端读取。</li>
<li>命令回复处理器全部写完到 socket 后，就会删除该socket的AE_WRITABLE事件和命令回复处理 器的映射。</li>
</ol>
<p>单线程快的原因：</p>
<ol>
<li>纯内存操作</li>
<li>核⼼是基于⾮阻塞的IO多路复⽤机制</li>
<li>单线程反⽽避免了多线程的频繁上下⽂切换带来的性能问题</li>
</ol>
<h2 id="简述Redis事务实现-1"><a href="#简述Redis事务实现-1" class="headerlink" title="简述Redis事务实现"></a>简述Redis事务实现</h2><ul>
<li>事务开始：MULTI命令的执⾏，标识着⼀个事务的开始。MULTI命令会将客户端状态的 flags属性 中打开REDIS_MULTI标识来完成的。</li>
<li>命令⼊队：当⼀个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执⾏不同 的操作。如果客  户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的⼀个，⽴即执⾏这个 命令，否则将命令放⼊⼀   个事务队列⾥⾯，然后向客户端返回QUEUED回复，如果客户端发送的 命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中⼀个，那么服务器⽴即执⾏这个命 令。如果客户端发送的是四个命令以外的其他命令，那么服务器并不⽴即执⾏这个命令。⾸先检查 此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性关闭  REDIS_MULTI 标识，并且返回错误信息给客户端。如果正确，将这个命令放⼊⼀个事务队列⾥ ⾯，然后向客户端返回 QUEUED 回复事务队列是按照FIFO的⽅式保存⼊队的命令</li>
<li>事务执⾏：客户端发送 EXEC 命令，服务器执⾏ EXEC 命令逻辑。如果客户端状态的 flags 属性 不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者REDIS_DIRTY_EXEC 标识，那么 就直接取消事务的执⾏。 否则客户端处于事务状态（flags有 REDIS_MULTI  标识），服务器会遍 历客户端的事务队列，然后执⾏事务队列中的所有命令，最后将返回结果全部返回给客户端； Redis不⽀持事务回滚机制，但是它会检查每⼀个事务中的命令是否错误。Redis事务不⽀持检查那 些程序员⾃⼰逻辑错误。例如对 String 类型的数据库键执⾏对 HashMap 类型的操作！</li>
</ul>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/WechatIMG19.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Luffy</div><div class="author-info-description">100%包拿Offer</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" href="/img/公众号.png"><i class="fab fa-weixin"></i><span>关注公众号</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zlf521000/JavaOfferToYou" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:luffy13453500082@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/img/WechatIMG35.jpg" target="_blank" title="微信"><i class="fab fa-weixin" style="color: #1AAD19;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">面试指导，100%帮您拿Offer，不拿Offer不收费！！！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/06/%E9%9D%A2%E8%AF%95%E9%A2%84%E7%BA%A6/" title="面试预约"><img src="https://s3.bmp.ovh/imgs/2024/11/03/af1f8123d6465a98.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试预约"/></a><div class="content"><a class="title" href="/2024/12/06/%E9%9D%A2%E8%AF%95%E9%A2%84%E7%BA%A6/" title="面试预约">面试预约</a><time datetime="2024-12-06T10:25:56.000Z" title="发表于 2024-12-06 18:25:56">2024-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/28/Autowird-vs-Resource/" title="Autowird_vs_Resource"><img src="https://s1.imagehub.cc/images/2024/11/28/bab171eb86cb158d84460d755e65e039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Autowird_vs_Resource"/></a><div class="content"><a class="title" href="/2024/11/28/Autowird-vs-Resource/" title="Autowird_vs_Resource">Autowird_vs_Resource</a><time datetime="2024-11-28T11:09:48.000Z" title="发表于 2024-11-28 19:09:48">2024-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89/" title="创建群聊客服聊天系统（4）"><img src="https://s1.imagehub.cc/images/2024/11/21/68f645d9cdba8f558c74809fe995a988.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建群聊客服聊天系统（4）"/></a><div class="content"><a class="title" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%884%EF%BC%89/" title="创建群聊客服聊天系统（4）">创建群聊客服聊天系统（4）</a><time datetime="2024-11-21T11:32:44.000Z" title="发表于 2024-11-21 19:32:44">2024-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89/" title="创建群聊客服聊天系统（3）"><img src="https://s1.imagehub.cc/images/2024/11/21/8ebb58f8f0a0b154cee1325a1f390106.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="创建群聊客服聊天系统（3）"/></a><div class="content"><a class="title" href="/2024/11/21/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%883%EF%BC%89/" title="创建群聊客服聊天系统（3）">创建群聊客服聊天系统（3）</a><time datetime="2024-11-21T11:32:39.000Z" title="发表于 2024-11-21 19:32:39">2024-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/17/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/" title="如何用TelegramBot创建群聊客服聊天系统（2）"><img src="https://s1.imagehub.cc/images/2024/11/17/b77975b53434e94225b9eb404f9ec652.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何用TelegramBot创建群聊客服聊天系统（2）"/></a><div class="content"><a class="title" href="/2024/11/17/%E5%88%9B%E5%BB%BA%E7%BE%A4%E8%81%8A%E5%AE%A2%E6%9C%8D%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/" title="如何用TelegramBot创建群聊客服聊天系统（2）">如何用TelegramBot创建群聊客服聊天系统（2）</a><time datetime="2024-11-17T14:12:25.000Z" title="发表于 2024-11-17 22:12:25">2024-11-17</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/VPN/" style="font-size: 1.1em; color: #999">VPN</a> <a href="/tags/Telegram-Bot/" style="font-size: 1.37em; color: #99a4b2">Telegram_Bot</a> <a href="/tags/Java/" style="font-size: 1.5em; color: #99a9bf">Java</a> <a href="/tags/Offer/" style="font-size: 1.23em; color: #999ea6">Offer</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      
    </div>
    <ul class="card-archive-list">
  
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2024/12/">
          <span class="card-archive-list-date">十二月 2024</span>
          <span class="card-archive-list-count">1</span>
        </a>
      </li>
    
      <li class="card-archive-list-item">
        <a class="card-archive-list-link" href="/archives/2024/11/">
          <span class="card-archive-list-date">十一月 2024</span>
          <span class="card-archive-list-count">19</span>
        </a>
      </li>
    </ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">20</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-12-06T10:34:29.510Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main></div><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Luffy</div></div></footer><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>