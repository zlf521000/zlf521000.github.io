---
layout: 如何用
title: 如何用TelegramBot创建群聊客服聊天系统（2）
date: 2024-11-17 22:12:25
tags: Telegram_Bot
cover: https://s1.imagehub.cc/images/2024/11/17/b77975b53434e94225b9eb404f9ec652.jpg
---
在上一部分，我们实现了机器人能够从群聊中识别提问，并将问题转发到指定客服窗口。本篇将继续深入，解决 客服如何通过群聊机器人回复客户，并将消息私聊反馈给客户 的问题。我们还会进一步优化系统功能，让整个客服系统更加智能化。
# 推荐正在找工作的朋友们：
[就业指导](https://github.com/zlf521000/JavaOfferToYou)   或 [面试指导](https://gitee.com/luffy521000/JavaOfferToYou) （不是机构）
公众号：**Java直达Offer**
微信：
[![添加微信](https://s1.imagehub.cc/images/2024/11/10/32be5f45c45cf77547ca4b1315febf1d.th.jpg)](https://www.imagehub.cc/image/wechatCode.C09gn4)
# 第四篇：实现客服通过机器人回复客户
要实现这一功能，我们需要在机器人中增加以下逻辑：

 1. 记录客户和问题的映射关系，方便客服回复时定位到客户。
 2. 识别客服的回复，并将其私聊发送给对应客户。
 3. 确保消息格式清晰，避免混淆。

## 1. 记录客户与问题的映射关系
当机器人接收到客户问题并转发给客服时，需要保存一个映射，记录客户的 Chat ID 和问题内容。可以通过一个 Map 数据结构来完成。

```java
import java.util.concurrent.ConcurrentHashMap;

// 定义一个全局变量，用于存储客户与问题的映射
private final ConcurrentHashMap<Long, Long> customerQuestionMap = new ConcurrentHashMap<>();

@Override
public void onUpdateReceived(Update update) {
    if (update.hasMessage() && update.getMessage().hasText()) {
        String messageText = update.getMessage().getText();
        Long chatId = update.getMessage().getChatId();

        // 判断是否是群聊消息
        if (update.getMessage().isGroupMessage() || update.getMessage().isSuperGroupMessage()) {
            // 如果消息提到了机器人，处理问题
            if (messageText.contains("@" + BOT_USERNAME)) {
                String question = messageText.replace("@" + BOT_USERNAME, "").trim();

                // 保存客户与问题映射
                customerQuestionMap.put(chatId, update.getMessage().getFrom().getId());

                // 转发问题到客服
                forwardToCustomerService(chatId, question);
            }
        }
    }
}

```
此处的 customerQuestionMap 保存了客户的 Chat ID 和与之对应的问题。我们将在客服回复时利用此数据。
## 2. 识别客服回复
当客服在群聊中回复客户问题时，需要机器人能够识别哪些消息是针对客户的回复，并将其私聊发送给客户。常见的方式是让客服通过 @客户 的形式明确回复。

实现代码
更新 onUpdateReceived 方法，增加对客服回复的识别和处理：

```java
@Override
public void onUpdateReceived(Update update) {
    if (update.hasMessage() && update.getMessage().hasText()) {
        String messageText = update.getMessage().getText();
        Long chatId = update.getMessage().getChatId();

        // 判断是否是群聊消息
        if (update.getMessage().isGroupMessage() || update.getMessage().isSuperGroupMessage()) {
            // 判断是否是回复消息
            if (messageText.startsWith("@")) {
                // 提取客户的 Chat ID（模拟格式为 "@客户12345"）
                Long customerChatId = extractCustomerIdFromMessage(messageText);

                // 回复内容
                String replyContent = extractReplyContent(messageText);

                // 私聊发送给客户
                sendReplyToCustomer(customerChatId, replyContent);
            }
        }
    }
}

// 从消息中提取客户的 Chat ID
private Long extractCustomerIdFromMessage(String messageText) {
    // 假设消息格式为 "@客户12345 内容"
    String[] parts = messageText.split(" ", 2);
    if (parts[0].startsWith("@客户")) {
        return Long.parseLong(parts[0].replace("@客户", ""));
    }
    return null;
}

// 从消息中提取回复内容
private String extractReplyContent(String messageText) {
    String[] parts = messageText.split(" ", 2);
    return parts.length > 1 ? parts[1] : "没有回复内容";
}

// 私聊发送回复给客户
private void sendReplyToCustomer(Long customerChatId, String replyContent) {
    SendMessage message = new SendMessage();
    message.setChatId(customerChatId);
    message.setText("客服回复您: " + replyContent);

    try {
        execute(message);
    } catch (TelegramApiException e) {
        e.printStackTrace();
    }
}

```
流程：

 1. 客服在群聊中回复客户时，通过 @客户12345 内容 的格式，明确指定客户。
 2. 机器人解析出客户 Chat ID 和回复内容。
 3. 使用 SendMessage 将回复内容私聊发送给客户。
## 3.增强消息格式与用户体验
为了提升系统的易用性，可以为客服提供更方便的格式，例如直接引用客户提问或加上标记。

优化消息显示
当客户提问时，机器人转发问题时可以加上问题编号或上下文，方便客服操作。

```java
private void forwardToCustomerService(Long chatId, String question) {
    Long customerServiceChatId = 123456789L; // 替换为实际客服 Chat ID

    String forwardMessage = "客户问题:\n" +
            "客户 ID: " + chatId + "\n" +
            "问题: " + question + "\n\n" +
            "请使用 @客户" + chatId + " 的格式回复客户";

    SendMessage message = new SendMessage();
    message.setChatId(customerServiceChatId);
    message.setText(forwardMessage);

    try {
        execute(message);
    } catch (TelegramApiException e) {
        e.printStackTrace();
    }
}

```
通过这种方式，客服能够快速找到问题的上下文。
# 第五篇：支持离线消息与多客服功能
在上面实现的基础功能之上，我们可以进一步优化，支持以下功能：

离线消息：当客服或客户不在线时，机器人能够缓存消息并在双方上线后通知。
多客服支持：如果有多个客服在同一个群中工作，系统需要分配任务并避免冲突。
## 1. 实现离线消息
使用 Redis 或数据库存储客户与客服之间的消息记录，确保离线消息能够在稍后交付。

存储消息逻辑示例：

```java
// 假设使用 ConcurrentHashMap 模拟数据库存储
private final ConcurrentHashMap<Long, List<String>> offlineMessages = new ConcurrentHashMap<>();

// 在客服不在线时存储消息
private void storeOfflineMessage(Long customerChatId, String message) {
    offlineMessages.computeIfAbsent(customerChatId, k -> new ArrayList<>()).add(message);
}

// 在客户上线时发送离线消息
private void sendOfflineMessages(Long customerChatId) {
    List<String> messages = offlineMessages.getOrDefault(customerChatId, Collections.emptyList());
    for (String message : messages) {
        sendReplyToCustomer(customerChatId, message);
    }
    offlineMessages.remove(customerChatId); // 清空已发送的消息
}

```
离线消息发送触发时机：

 - 当客户再次发送消息时，机器人可以检查是否存在未读离线消息并一并发送。
## 2. 多客服分配
如果多个客服同时在线，可以实现一个简单的任务分配机制。例如：
 - 轮流分配客户问题。
 - 指定客服负责某些客户。

我们将在后续的博客中详细实现多客服系统，敬请期待！

本篇内容覆盖了 群聊客服系统中最核心的实现：通过机器人完成提问转发和回复私聊。在下一篇中，我们将继续扩展更多高级功能，敬请期待！